import { IndicatorOptions, IndicatorType, TabControllerOptions } from './types';import Utils from './utils';const indicatorOptionsDefaultValue: IndicatorOptions = {  width: 'cover',  height: '2px',  type: IndicatorType.underline,  backgroundColor: '#409eff',};export default class TabController<T> {  get tabContainer() {    return this.tabsDom.querySelector('.__cus-tab-container') as HTMLDivElement;  }  get currentIndex() {    return this._currentIndex;  }  public get data() {    return this._data;  }  get transition() {    return `transform ${this.duration / 1000}s`;  }  get indicatorTransition() {    return `transform ${this.duration / 1000}s,width ${this.duration / 1000}s`;  }  get topTips(): HTMLDivElement[] {    return Array.from(this.tabsDom.querySelectorAll('[data-cus-tab-tip]')) as HTMLDivElement[];  }  get tabsDom() {    const res = document.querySelector(this.selector);    if (!res) {      throw new Error('tabs selector is invalid');    }    return res as HTMLDivElement;  }  get containersWrap(): HTMLDivElement {    return this.tabsDom.querySelector(`.__cus-tab-container-items-wrap`) as HTMLDivElement;  }  get tabBar(): HTMLElement {    const tabs = this.tabsDom;    const result = tabs.querySelector(`.${this.tabBarClass}`) as HTMLElement;    if (!result) {      throw new Error('tar bar id error');    }    return result;  }  get tabDomItems(): HTMLDivElement[] {    const tabBar = this.tabBar;    if (!tabBar) {      throw new Error('tab bar is undefined,tab bar id error');    }    // __cus-tabs-wrap    return Array.from(tabBar.querySelector(`.${this.tabsWrapClass}`)!.children) as HTMLDivElement[];  }  get tabContainers() {    return Array.from(this.tabsDom.querySelectorAll('.__cus-tab-container-item')) as HTMLDivElement[];  }  get tabContainerWidth() {    return this.tabsDom.offsetWidth;  }  get tabBarTotalWidth(): number {    return this.tabDomItems.reduce((total, item) => {      return total + item.offsetWidth;    }, 0);  }  get indicator(): HTMLDivElement {    return this.tabsDom.querySelector('#__cus-indicator') as HTMLDivElement;  }  get loadingAreaHeight(): number {    return this.tabContainers[0].querySelector<HTMLDivElement>('.__cus-loading-area')!.offsetHeight;  }  get lockSlide() {    return this._lockSlide;  }  get lockPutDown() {    return this._lockPutDown;  }  set lockPutDown(val) {    this._lockPutDown = val;  }  set lockSlide(val) {    this._lockSlide = val;  }  // 切换tab后的回调  public onChange: (index: number, data: T) => void;  // 当前tab文字颜色  private activeColor: string;  // 未激活tab文字颜色  private inactiveColor: string;  // 滑动起始点  private touchStartPoint: number[] = [];  // 当前滑动触摸点  private touchCurrentPoint: number[] = [];  // 滑动灵敏度（滑动距离超过这个值即发生滑动，越低越灵敏）  private distanceThreshold = 5;  // 快速滑动时触发切换tab的阈值  private slideThreshold = 40;  // 当前tab序号  private _currentIndex = 0;  // 已滑动横向距离  private distX = 0;  // 已滑动纵向距离  private distY = 0;  // 滑动起始点到当前点的距离  private distance = 0;  // 滑动开始时间  private touchBeginTime = 0;  // 滑动开始时容器的Transform值  private beginTransform = 0;  // 滑动动画持续时间  private duration: number;  // 数据  private _data: T[];  // 边缘是否回弹  private rebound: boolean;  // tab是否允许滚动  private tabCanScroll: boolean;  // tab bar的class属性  private tabBarClass: string = '__cus-tab-bar';  // tab container的class属性  private tabContainerClass: string = '__cus-tab-container';  private putDowning = false;  // 容器滚动到底部触发  private onScrollEnd: (i: number) => void | null;  // 触发onScrollEnd hook的偏移值  private scrollEndOffset: number;  // 组件根元素选择器  private selector: string;  private tabsWrapClass = '__cus-tabs-items-wrap';  // 用来标识已初始化的tab的key  private tabInitKey = '__tabInit';  // 默认颜色  private defaultColor = '#409eff';  private _lockSlide = false;  private _lockPutDown = false;  private indicatorOptions: IndicatorOptions;  private isShowingTopTip = false;  private onPutDownRefresh?: (i: number) => Promise<void>;  constructor(options?: TabControllerOptions<T>) {    const {      selector = '#__cus-tabs',      tabScroll = false, rebound = false, initIndex = 0, data = [], onChange = () => {      }, indicatorOptions = {        backgroundColor: this.defaultColor,        height: '2px',        width: 'cover',        type: IndicatorType.underline,      }, activeColor = this.defaultColor, inactiveColor = '#000',      duration = 500,      scrollEndOffset = 0,      onScrollEnd = null,      onPutDownRefresh = null,    } = options || {};    this.selector = selector;    const tabs = document.querySelector(selector) as HTMLDivElement;    if (!tabs) {      throw new Error('tabs is not found');    }    const tabBar = tabs.querySelector(`.${this.tabBarClass}`)! as HTMLDivElement;    const tabContainer = tabs.querySelector(`.${this.tabContainerClass}`) as HTMLDivElement;    if (!tabBar) {      throw new Error('tab bar id error');    }    if (!tabContainer) {      throw new Error('tab container id error');    }    indicatorOptions.height = indicatorOptions.height || indicatorOptionsDefaultValue.height;    indicatorOptions.backgroundColor = indicatorOptions.backgroundColor || indicatorOptionsDefaultValue.backgroundColor;    indicatorOptions.type = indicatorOptions.type || indicatorOptionsDefaultValue.type;    indicatorOptions.width = indicatorOptions.width || indicatorOptionsDefaultValue.width;    this.onPutDownRefresh = onPutDownRefresh as any;    this.onScrollEnd = onScrollEnd as any;    this.scrollEndOffset = scrollEndOffset;    this.duration = duration;    this.inactiveColor = inactiveColor;    this.activeColor = activeColor;    this._currentIndex = 0;    this.rebound = rebound;    this.onChange = onChange;    this._data = data;    this.tabCanScroll = tabScroll;    this.indicatorOptions = indicatorOptions;    const containersWrap = this.containersWrap;    const indicator = tabBar.querySelector<HTMLDivElement>('#__cus-indicator')!;    indicator.style.backgroundColor = indicatorOptions.backgroundColor!;    indicator.style.transition = this.indicatorTransition;    indicator.style.height = indicatorOptions.height || '2px';    tabBar.style.visibility = 'hidden';    tabContainer.style.visibility = 'hidden';    setTimeout(() => {      tabBar.style.visibility = 'visible';      tabContainer.style.visibility = 'visible';      const tabContainers = Array.from(containersWrap.children) as HTMLDivElement[];      containersWrap.style.width = tabContainers.length * this.tabContainerWidth + 'px';      window.addEventListener('resize', this.syncWidth);      const tabDomItems = this.tabDomItems!;      tabDomItems.forEach((o) => {        o.style.color = this.inactiveColor;        o.dataset[this.tabInitKey] = 'true';      });      // 初始化已激活tab      setTimeout(() => {        // indicator.style.transition = 'none';        this.syncIndicator(false);        requestAnimationFrame(() => {          indicator.style.transition = this.indicatorTransition;        });        tabDomItems[initIndex].style.color = this.activeColor;      });      containersWrap.style.transform = `translateX(0px)`;      // 初始化loading-area      const loadAreas = Array.from(containersWrap.querySelectorAll('.__cus-loading-area')) as HTMLDivElement[];      loadAreas.forEach((o) => {        o.style.top = -o.offsetHeight + 'px';      });      if (!this.tabCanScroll) {        const tabsWrap = tabBar.querySelector<HTMLDivElement>('.__cus-tabs-wrap')!;        tabsWrap.style.display = 'flex';        tabsWrap.style.width = '100%';        tabsWrap.style.whiteSpace = 'normal';      }      tabDomItems.forEach((item) => {        if (!this.tabCanScroll) {          item.style.flex = '1';        }        item.addEventListener('click', this.handleTabClick);      });      this.addTouchListeners();      tabContainers.forEach((container) => {        this.addContainerScrollListener(container);      });      this.changeTab(initIndex);    });  }  public push = (tabItem: T) => {    const containersWrap = this.containersWrap;    containersWrap.style.width = `${containersWrap.offsetWidth + this.tabContainerWidth}px`;    this._data.push(tabItem);    setTimeout(() => {      this.syncWidth();      const tabDomItems = this.tabDomItems;      const uninitializedTabs = tabDomItems.filter((o) => {        return !o.dataset[this.tabInitKey];      });      uninitializedTabs.forEach((newTab) => {        const containers = this.tabContainers;        newTab.addEventListener('click', this.handleTabClick);        this.addContainerScrollListener(containers[containers.length - 1]);      });    });  }  public remove = (i: number) => {    this._data.splice(i, 1);    const currentIndex = this.currentIndex;    if (i === currentIndex) {      this.changeTab(currentIndex === 0 ? 0 : currentIndex - 1);    }    setTimeout(() => {      this.syncWidth();    });  }  public changeTab: (targetIndex: number, isAnimate?: boolean) => void = (targetIndex, isAnimate = true) => {    const { indicator, containersWrap: containersWrap, _data } = this;    if (targetIndex >= _data.length) {      console.warn('target index out of range');      return;    }    this.onChange(targetIndex, _data[targetIndex]);    if (targetIndex === this._currentIndex) {      return;    }    const tabContainer = this.tabContainer;    const tabContainerItemWidth = tabContainer.offsetWidth;    const tabBarItems = this.tabDomItems!;    const targetTab = tabBarItems[targetIndex];    tabBarItems.forEach((o) => {      o.style.color = this.inactiveColor;      o.classList.remove('active');    });    this._currentIndex = targetIndex;    targetTab.classList.add('active');    targetTab.style.color = this.activeColor;    // 移动到相应tab    this.syncIndicator(isAnimate);    containersWrap.style.transition = isAnimate ? this.transition : 'none';    setTimeout(() => {      containersWrap.style.transform = `translateX(${-tabContainerItemWidth * targetIndex}px)`;      setTimeout(() => {        containersWrap.style.transition = this.transition;      });    });    // 处理tab bar 滚动    if (this.tabCanScroll) {      const tabBarWrap = this.tabBar.querySelector('.__cus-tabs-wrap') as HTMLDivElement;      const tabBarSpace = 50;      const targetTabOffsetLeft = targetTab.offsetLeft;      const targetTabWidth = targetTab.offsetWidth;      const tabBarScrollLeft = tabBarWrap.scrollLeft;      const tabBarViewWidth = tabBarWrap.offsetWidth;      const rightBoundary = targetTabOffsetLeft + targetTabWidth + tabBarSpace;      const leftBoundary = targetTabOffsetLeft - tabBarSpace;      const tabBarTotalWidth = this.tabBarTotalWidth;      if (rightBoundary > tabBarScrollLeft + tabBarViewWidth) {        if (rightBoundary >= tabBarTotalWidth) {          Utils.animateScrollTo(tabBarWrap, { x: tabBarTotalWidth - tabBarViewWidth, y: 0 }, this.duration);        } else {          Utils.animateScrollTo(tabBarWrap, { x: rightBoundary - tabBarViewWidth, y: 0 }, this.duration);        }      }      if (leftBoundary < tabBarScrollLeft) {        Utils.animateScrollTo(tabBarWrap, { x: leftBoundary < 0 ? 0 : leftBoundary, y: 0 }, this.duration);      }    }  }  public getTransformX(transform: string): number {    if (!transform || transform === 'none') {      return 0;    }    if (transform.startsWith('translateX')) {      return parseInt(transform.match(/translateX\(([\-0-9\.]+)px\)/)![1], 10);    }    if (transform.startsWith('matrix')) {      return parseInt(transform.match(/matrix\(.*? ([\-0-9\.]+), [0-9\.]+\)/)![1], 10);    }    console.warn('unknown transform');    return 0;  }  /*  public showTopTip = (content: string, duration: number, delay: number = 300) => {      const topTips = this.topTips;      if (!topTips.length) {        console.warn('no tip set');        return;      }      if (this.isShowingTopTip) {        return;      }      this.isShowingTopTip = true;      const topTip = this.topTips[this._currentIndex];      topTip.style.display = 'block';      const contentArea = topTip.querySelector(`[data-cus-tab-tip-content]`) as HTMLElement;      if (!contentArea) {        console.warn('content area not found.add a data-cus-tab-tip-content'+         'attribute to the element that needs to display content');      }      contentArea.innerHTML = content;      setTimeout(() => {        topTip.classList.add('show');        setTimeout(() => {          topTip.classList.remove('show');          setTimeout(() => {            topTip.style.display = 'none';            this.isShowingTopTip = false;          }, delay);        }, duration);      }, 20);    }*/  private syncIndicator = (isAnimate: boolean = true) => {    const { indicatorOptions, tabDomItems, indicator } = this;    const oTransition = indicator.style.transition;    const sync = () => {      const textNode = tabDomItems[this._currentIndex].querySelector<HTMLDivElement>('[data-text-node]')!;      if (indicatorOptions.width === 'cover') {        indicator.style.width = tabDomItems[0].offsetWidth + 'px';      } else if (indicatorOptions.width === 'content' || Utils.isPercent(indicatorOptions.width!)) {        const rate = indicatorOptions.width === 'content' ? 1 : Utils.parsePercent(indicatorOptions.width!);        const textNodeWidth = textNode.offsetWidth;        indicator.style.width = textNodeWidth * rate + 'px';        indicator.style.transform = `translateX(${Utils.getOffset(textNode).left + (textNodeWidth - textNodeWidth * rate) / 2}px)`;      } else {        throw new Error('indicator width option is invalid (valid value:cover,content)');      }      requestAnimationFrame(() => {        indicator.style.transition = oTransition;      });    };    if (isAnimate) {      indicator.style.transition = this.indicatorTransition;      requestAnimationFrame(sync);    } else {      indicator.style.transition = 'none';      sync();    }  }  private addTouchListeners = () => {    const data = this._data;    const containersWrap = this.containersWrap;    const indicator = this.indicator;    const tabDomItems = this.tabDomItems;    const handleTransitionEnd = () => {      containersWrap.style.transition = this.transition;    };    containersWrap.addEventListener('webkitTransitionEnd', handleTransitionEnd);    containersWrap.addEventListener('transitionend', handleTransitionEnd);    containersWrap.addEventListener('touchstart', (e) => {      const touch = e.touches[0];      this.touchStartPoint = [touch.clientX, touch.clientY];      this.touchBeginTime = Date.now();      containersWrap.style.transform = getComputedStyle(containersWrap).transform;      containersWrap.style.transition = 'none';      try {        this.beginTransform = this.getTransformX(containersWrap.style.transform!);      } catch (e) {        console.log(containersWrap.style.transform);      }      indicator.style.transition = 'none';    });    containersWrap.addEventListener('touchmove', (e) => {      const touch = e.touches[0];      this.touchCurrentPoint = [touch.clientX, touch.clientY];      this.distX = this.touchCurrentPoint[0] - this.touchStartPoint[0];      this.distY = this.touchCurrentPoint[1] - this.touchStartPoint[1];      const { distX, distY } = this;      this.distance = Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2));      const distance = this.distance;      const currentContainer = this.tabContainers[this._currentIndex];      // 处理左右滑动      if (distance > this.distanceThreshold && Math.abs(distX) > Math.abs(distY) && !this.lockSlide) {        if (this._currentIndex === 0 && !this.rebound && distX > 0) {          return;        }        if (this._currentIndex === this._data.length - 1 && !this.rebound && distX < 0) {          return;        }        const tabContainerWidth = this.tabContainerWidth;        const rate = Math.abs(distX / tabContainerWidth);        const currentTab = tabDomItems[this._currentIndex];        const currentTabWidth = currentTab.offsetWidth;        const currentTabLeft = currentTab.offsetLeft;        const targetTab = distX > 0 ? tabDomItems[this._currentIndex - 1] : tabDomItems[this._currentIndex + 1];        const diffWidth = targetTab.offsetWidth - currentTab.offsetWidth;        const distanceX = currentTab.offsetLeft - targetTab.offsetLeft;        const { indicatorOptions } = this;        if (this.indicatorOptions.width === 'cover') {          indicator.style.width = currentTabWidth + diffWidth * rate + 'px';          indicator.style.transform = `translateX(${currentTabLeft - distanceX * rate}px`;        } else if (indicatorOptions.width === 'content' || Utils.isPercent(indicatorOptions.width!)) {          const tabRate = indicatorOptions.width === 'content' ? 1 : Utils.parsePercent(indicatorOptions.width!);          const currentTabTextNode = tabDomItems[this._currentIndex].querySelector<HTMLElement>('[data-text-node]')!;          const currentTabTextRealWidth = currentTabTextNode.offsetWidth * tabRate;          const currentTabTextNodeOffsetLeft = Utils.getOffset(currentTabTextNode).left + (currentTabTextNode.offsetWidth - currentTabTextRealWidth) / 2;          const targetTabTextNode = targetTab.querySelector<HTMLElement>('[data-text-node]')!;          const targetTabTextNodeRealWidth = targetTabTextNode.offsetWidth * tabRate;          const targetTabTextNodeOffsetLeft = Utils.getOffset(targetTabTextNode).left + (targetTabTextNode.offsetWidth - currentTabTextRealWidth) / 2;          const textNodeDiffWidth = targetTabTextNodeRealWidth - currentTabTextRealWidth;          const textNodeDistanceX = currentTabTextNodeOffsetLeft - targetTabTextNodeOffsetLeft;          indicator.style.width = (currentTabTextRealWidth + textNodeDiffWidth * rate) + 'px';          indicator.style.transform = `translateX(${currentTabTextNodeOffsetLeft - textNodeDistanceX * rate}px`;        } else {          throw new Error('indicator width option is invalid (valid value:cover,content)');        }        containersWrap.style.transform = `translateX(${this.beginTransform + distX}px)`;      } else if (this.onPutDownRefresh &&        (this.putDowning || (distance > this.distanceThreshold && Math.abs(distX) < Math.abs(distY) && currentContainer.scrollTop === 0))) {        // 处理下拉刷新        this.lockSlide = true;        this.putDowning = true;        const currentContainerWrap = currentContainer.querySelector('.__cus-tab-container-item-content-wrap') as HTMLDivElement;        const loadingArea = currentContainer.querySelector('.__cus-loading-area') as HTMLDivElement;        if (currentContainer.scrollTop === 0) {          currentContainerWrap.style.transition = 'none';          currentContainerWrap.style.transform = `translateY(${distY / 2}px)`;          loadingArea.style.transition = `none`;          loadingArea.style.transform = `translateY(${distY / 2}px)`;        }      }    });    containersWrap.addEventListener('touchend', () => {      indicator.style.transition = this.indicatorTransition;      const currentTabContainerWidth = this.tabContainerWidth;      // 处理下拉刷新      if (this.onPutDownRefresh && this.putDowning) {        this.putDowning = false;        const loadingAreaHeight = this.loadingAreaHeight;        const currentContainer = this.tabContainers[this._currentIndex];        const currentContainerWrap = currentContainer.querySelector('.__cus-tab-container-item-content-wrap') as HTMLDivElement;        const loadingArea = currentContainer.querySelector('.__cus-loading-area') as HTMLDivElement;        currentContainerWrap.style.transition = `transform .3s`;        loadingArea.style.transition = `transform .3s`;        if (this.distY > this.loadingAreaHeight) {          currentContainerWrap.style.transform = `translateY(${loadingAreaHeight}px)`;          loadingArea.style.transform = `translateY(${loadingAreaHeight}px)`;          this.onPutDownRefresh(this._currentIndex).then(() => {            loadingArea.style.transform = `none`;            currentContainerWrap.style.transform = `none`;          });        } else {          currentContainerWrap.style.transform = `none`;          loadingArea.style.transform = `none`;        }      }      const reset = () => {        containersWrap.style.transition = this.transition;        containersWrap.style.transform = `translateX(${-this._currentIndex * currentTabContainerWidth}px)`;        // 指示器归位        // indicator.style.transition = this.indicatorTransition;        this.syncIndicator();      };      if (        (this._currentIndex === 0 && this.distX > 0) ||        (this._currentIndex === data.length - 1 && this.distX < 0)      ) {        // 归位        reset();        return;      }      const duration = Date.now() - this.touchBeginTime;      if (duration < 500 && !this.lockSlide) {        if (this.distX > this.slideThreshold) {          this.changeTab(this._currentIndex - 1);          return;        }        if (-this.distX > this.slideThreshold) {          this.changeTab(this._currentIndex + 1);          return;        }      } else {        if (this.distX > currentTabContainerWidth / 2) {          this.changeTab(this._currentIndex - 1);          return;        }        if (-this.distX > currentTabContainerWidth / 2) {          this.changeTab(this._currentIndex + 1);          return;        }      }      reset();      // this.setLockSlide(false);      this.lockSlide = false;    });  }  private addContainerScrollListener = (container: HTMLDivElement) => {    container.addEventListener('scroll', (e) => {      const target = e.target as HTMLDivElement;      // this.？setLockSlide(true);      this.lockSlide = true;      if (target.scrollTop + target.offsetHeight >= target.scrollHeight - this.scrollEndOffset) {        this.onScrollEnd(this.currentIndex);      }    });  }  private syncWidth = () => {    const containersWrap = this.containersWrap;    const tabContainerItems = Array.from(containersWrap.children) as HTMLDivElement[];    const tabDomItems = this.tabDomItems!;    const containerItemWidth = this.tabContainerWidth;    containersWrap.style.width = tabContainerItems.length * containerItemWidth + 'px';    tabContainerItems.forEach((container) => {      container.style.width = containerItemWidth + 'px';      containersWrap.style.width = tabContainerItems.length * containerItemWidth + 'px';    });    setTimeout(() => {      this.syncIndicator(false);    });    containersWrap.style.transition = 'none';    containersWrap.style.transform = `translateX(${-this.currentIndex * containerItemWidth}px)`;  }  private handleTabClick = (e: Event) => {    const clickedTab = e.currentTarget as HTMLDivElement;    const tabDomItems = this.tabDomItems;    const targetIndex = tabDomItems!.findIndex((o) => o === clickedTab);    this.changeTab(targetIndex);  }}
