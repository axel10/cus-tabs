import { IndicatorOptions, TabControllerOptions } from './types';import Utils from './utils';// todo 分离触摸结束动画const indicatorOptionsDefaultValue: IndicatorOptions = {  width: 'cover',  height: '2px',  backgroundColor: '#409eff',};export default class TabController<T> {  get tabContainer() {    return this.tabsDom.querySelector('.__cus-tab-container') as HTMLDivElement;  }  get currentIndex() {    return this._currentIndex;  }  public get data() {    return this._data;  }  /*  get touchEndTransition() {      return `transform ${this.touchEndTransitionTime / 1000}s`;    }*/  get tabsDom() {    const res = document.querySelector(this.selector);    if (!res) {      throw new Error('tabs selector is invalid');    }    return res as HTMLDivElement;  }  get containersWrap(): HTMLDivElement {    return this.tabsDom.querySelector(`.__cus-tab-container-items-wrap`) as HTMLDivElement;  }  get tabBar(): HTMLElement {    const tabs = this.tabsDom;    const result = tabs.querySelector(`.${this.tabBarClass}`) as HTMLElement;    if (!result) {      throw new Error('tar bar id error');    }    return result;  }  get tabBarItems(): HTMLDivElement[] {    const tabBar = this.tabBar;    if (!tabBar) {      throw new Error('tab bar is undefined,tab bar id error');    }    // __cus-tabs-wrap    return Array.from(tabBar.querySelector(`.${this.tabBarWrapClass}`)!.children) as HTMLDivElement[];  }  get tabContainers() {    return Array.from(this.tabsDom.querySelectorAll('.__cus-tab-container-item')) as HTMLDivElement[];  }  get tabContainerWidth() {    return this.tabsDom.offsetWidth;  }  get tabBarTotalWidth(): number {    return this.tabBarItems.reduce((total, item) => {      return total + item.offsetWidth;    }, 0);  }  get indicator(): HTMLDivElement {    return this.tabsDom.querySelector('#__cus-indicator') as HTMLDivElement;  }  get loadingAreaHeight(): number {    return this.tabContainers[0].querySelector<HTMLDivElement>('.__cus-loading-area')!.offsetHeight;  }  get lockSlide() {    return this._lockSlide;  }  get lockPutDown() {    return this._lockPutDown;  }  get tabsWrap() {    return this.tabBar.querySelector<HTMLDivElement>('.__cus-tabs-items-wrap')!;  }  set lockPutDown(val) {    this._lockPutDown = val;  }  set lockSlide(val) {    this._lockSlide = val;  }  // 切换tab后的回调  public onChange: (index: number, data: T) => void;  // 滑动起始点  private touchStartPoint: number[] = [];  // 当前滑动触摸点  private touchCurrentPoint: number[] = [];  // 滑动灵敏度（滑动距离超过这个值即发生滑动，越低越灵敏）  private distanceThreshold = 5;  // 快速滑动时触发切换tab的阈值  private slideThreshold = 40;  // 当前tab序号  private _currentIndex = 0;  // 已滑动横向距离  private distX = 0;  // 已滑动纵向距离  private distY = 0;  // 滑动起始点到当前点的距离  private distance = 0;  // 滑动开始时间  private touchBeginTime = 0;  // 滑动开始时容器的Transform值  private beginTransform = 0;  // 滑动动画持续时间  private duration: number;  // 数据  private _data: T[];  // 边缘是否回弹  private rebound: boolean;  // tab是否允许滚动  private tabScroll: boolean;  // tab bar的class属性  private tabBarClass: string = '__cus-tab-bar';  // tab container的class属性  private tabContainerClass: string = '__cus-tab-container';  // 容器滚动到底部触发  private onScrollEnd: (i: number) => void | null;  // 触发onScrollEnd hook的偏移值  private scrollEndOffset: number;  // 组件根元素选择器  private selector: string;  private tabBarWrapClass = '__cus-tabs-items-wrap';  // 用来标识已初始化的tab的key  private tabInitKey = '__tabInit';  // 默认颜色  private defaultColor = '#409eff';  private _lockSlide = false;  private _lockPutDown = false;  private indicatorOptions: IndicatorOptions;  private touchSliding = false;  private tabInactiveClass = 'inactive';  private tabActiveClass = 'active';  private inactiveColor?: string;  private activeColor?: string;  private touchEndTransitionTime = 500;  constructor(options: TabControllerOptions<T>) {    const {      selector = '#__cus-tabs',      tabScroll = false, rebound = false, initIndex = 0, data, onChange = () => {      }, indicatorOptions = {        backgroundColor: this.defaultColor,        height: '2px',        width: 'cover',      },      duration = 500,      scrollEndOffset = 0,      onScrollEnd = null,      touchEndTransitionTime = 500,      activeColor,      inactiveColor,    } = options;    this.selector = selector;    const tabs = document.querySelector(selector) as HTMLDivElement;    if (!tabs) {      throw new Error('tabs is not found');    }    const tabBar = tabs.querySelector(`.${this.tabBarClass}`)! as HTMLDivElement;    const tabContainer = tabs.querySelector(`.${this.tabContainerClass}`) as HTMLDivElement;    if (!tabBar) {      throw new Error('tab bar id error');    }    if (!tabContainer) {      throw new Error('tab container id error');    }    indicatorOptions.height = indicatorOptions.height || indicatorOptionsDefaultValue.height;    indicatorOptions.backgroundColor = indicatorOptions.backgroundColor || indicatorOptionsDefaultValue.backgroundColor;    indicatorOptions.width = indicatorOptions.width || indicatorOptionsDefaultValue.width;    // this.tabAnimation = tabAnimation;    // this.containerAnimation = containerAnimation;    this.onScrollEnd = onScrollEnd as any;    this.scrollEndOffset = scrollEndOffset;    this.duration = duration;    this._currentIndex = 0;    this.rebound = rebound;    this.onChange = onChange;    this._data = data;    this.tabScroll = tabScroll;    this.indicatorOptions = indicatorOptions;    this.touchEndTransitionTime = touchEndTransitionTime;    this.inactiveColor = inactiveColor;    this.activeColor = activeColor;    const containersWrap = this.containersWrap;    const indicator = tabBar.querySelector<HTMLDivElement>('#__cus-indicator')!;    indicator.style.backgroundColor = indicatorOptions.backgroundColor!;    indicator.style.height = indicatorOptions.height || '2px';    tabBar.style.visibility = 'hidden';    tabContainer.style.visibility = 'hidden';    indicator.style.transition = 'none';    setTimeout(() => {      const tabContainers = Array.from(containersWrap.children) as HTMLDivElement[];      containersWrap.style.width = tabContainers.length * this.tabContainerWidth + 'px';      window.addEventListener('resize', this.syncWidth);      const tabBarItems = this.tabBarItems!;      tabBarItems.forEach((o) => {        o.classList.add(this.tabInactiveClass);        o.dataset[this.tabInitKey] = 'true';        this.inactiveColor && (o.style.color = this.inactiveColor);      });      // 初始化已激活tab      // indicator.style.transition = 'none';      this.syncIndicator(false);      /*      requestAnimationFrame(() => {              indicator.style.transition = this.indicatorTransition();            });*/      tabBarItems[initIndex].classList.remove(this.tabInactiveClass);      tabBarItems[initIndex].classList.add(this.tabActiveClass);      this.activeColor && (tabBarItems[initIndex].style.color = this.activeColor)      containersWrap.style.transform = `translateX(0px)`;      // 初始化loading-area      const loadAreas = Array.from(containersWrap.querySelectorAll('.__cus-loading-area')) as HTMLDivElement[];      loadAreas.forEach((o) => {        o.style.top = -o.offsetHeight + 'px';      });      if (!this.tabScroll) {        const tabsWrap = this.tabsWrap;        tabsWrap.style.display = 'flex';        tabsWrap.style.width = '100%';        tabsWrap.style.whiteSpace = 'normal';      }      tabBarItems.forEach((item) => {        if (!this.tabScroll) {          item.style.flex = '1';        }        item.addEventListener('click', this.handleTabClick);      });      this.addTouchListeners();      this.containersWrap.addEventListener('transitionend', (e) => {        this.touchSliding = false;      });      tabContainers.forEach((container) => {        this.initContainerListeners(container);      });      this.changeTab(initIndex, false);      requestAnimationFrame(() => {        tabBar.style.visibility = 'visible';        tabContainer.style.visibility = 'visible';      });    });  }  public push = (tabItem: T) => {    const containersWrap = this.containersWrap;    containersWrap.style.width = `${containersWrap.offsetWidth + this.tabContainerWidth}px`;    this._data.push(tabItem);    requestAnimationFrame(() => {      this.syncWidth();      const tabBarItems = this.tabBarItems;      const uninitializedTabs = tabBarItems.filter((o) => {        return !o.dataset[this.tabInitKey];      });      const containers = this.tabContainers;      uninitializedTabs.forEach((newTab) => {        this.inactiveColor && (newTab.style.color = this.inactiveColor);        newTab.addEventListener('click', this.handleTabClick);        this.initContainerListeners(containers[containers.length - 1]);      });    });  }  public remove = (i: number) => {    this._data.splice(i, 1);    const currentIndex = this.currentIndex;    if (i === currentIndex) {      this.changeTab(currentIndex === 0 ? 0 : currentIndex - 1);    }    setTimeout(() => {      this.syncWidth();    });  }  public changeTab: (targetIndex: number, isAnimate?: boolean, time?: number) => void = (targetIndex, isAnimate = true, time) => {    const { containersWrap: containersWrap, _data } = this;    if (targetIndex >= _data.length) {      console.warn('target index out of range');      return;    }    this.onChange(targetIndex, _data[targetIndex]);    if (targetIndex === this._currentIndex) {      return;    }    const tabContainer = this.tabContainer;    const tabContainerItemWidth = tabContainer.offsetWidth;    const tabBarItems = this.tabBarItems!;    const targetTab = tabBarItems[targetIndex];    tabBarItems.forEach((o) => {      o.classList.add(this.tabInactiveClass);      o.classList.remove(this.tabActiveClass);      this.inactiveColor && (o.style.color = this.inactiveColor);    });    this._currentIndex = targetIndex;    targetTab.classList.add(this.tabActiveClass);    this.activeColor && (targetTab.style.color = this.activeColor);    // 移动到相应tab    this.syncIndicator(isAnimate, time);    containersWrap.style.transition = (isAnimate || (this.touchSliding)) ? this.transition(time) : 'none';    requestAnimationFrame(() => {      containersWrap.style.transform = `translateX(${-tabContainerItemWidth * targetIndex}px)`;    });    // 处理tab bar 滚动    if (this.tabScroll) {      const tabBarWrap = this.tabBar.querySelector('.__cus-tabs-wrap') as HTMLDivElement;      const tabBarSpace = 50;      const targetTabOffsetLeft = targetTab.offsetLeft;      const targetTabWidth = targetTab.offsetWidth;      const tabBarScrollLeft = tabBarWrap.scrollLeft;      const tabBarViewWidth = tabBarWrap.offsetWidth;      const rightBoundary = targetTabOffsetLeft + targetTabWidth + tabBarSpace;      const leftBoundary = targetTabOffsetLeft - tabBarSpace;      const tabBarTotalWidth = this.tabBarTotalWidth;      if (rightBoundary > tabBarScrollLeft + tabBarViewWidth) {        if (rightBoundary >= tabBarTotalWidth) {          Utils.animateScrollTo(tabBarWrap, { x: tabBarTotalWidth - tabBarViewWidth, y: 0 }, this.duration);        } else {          Utils.animateScrollTo(tabBarWrap, { x: rightBoundary - tabBarViewWidth, y: 0 }, this.duration);        }      }      if (leftBoundary < tabBarScrollLeft) {        Utils.animateScrollTo(tabBarWrap, { x: leftBoundary < 0 ? 0 : leftBoundary, y: 0 }, this.duration);      }    }  }  public getTransformX(transform: string): number {    if (!transform || transform === 'none') {      return 0;    }    if (transform.startsWith('translateX')) {      return parseInt(transform.match(/translateX\(([\-0-9\.]+)px\)/)![1], 10);    }    if (transform.startsWith('matrix')) {      return parseInt(transform.match(/matrix\(.*? ([\-0-9\.]+), [0-9\.]+\)/)![1], 10);    }    console.warn('unknown transform');    return 0;  }  private transition(time?: number) {    return `transform ${time !== undefined ? time / 1000 : this.duration / 1000}s`;  }  private indicatorTransition(time?: number) {    const distTime = time !== undefined ? time / 1000 : this.duration / 1000;    return `transform ${distTime}s,width ${distTime}s`;  }  private syncIndicator = (isAnimate: boolean = true, transitionTime?: number) => {    const { indicatorOptions, tabBarItems, indicator } = this;    // const oTransition = indicator.style.transition;    const sync = () => {      const targetTab = tabBarItems[this._currentIndex];      const textNode = targetTab.querySelector<HTMLDivElement>('[data-text-node]')!;      if (indicatorOptions.width === 'cover') {        indicator.style.width = targetTab.offsetWidth + 'px';        indicator.style.transform = `translateX(${Utils.getOffsetLeft(targetTab)}px)`;      } else if (indicatorOptions.width === 'content' || Utils.isPercent(indicatorOptions.width!)) {        const rate = indicatorOptions.width === 'content' ? 1 : Utils.parsePercent(indicatorOptions.width!);        const textNodeWidth = textNode.offsetWidth;        indicator.style.width = textNodeWidth * rate + 'px';        indicator.style.transform = `translateX(${Utils.getOffsetLeft(textNode) + (textNodeWidth - textNodeWidth * rate) / 2}px)`;      } else {        throw new Error('indicator width option is invalid (valid value:cover,content)');      }    };    indicator.style.transition = isAnimate ? this.indicatorTransition(transitionTime) : 'none';    requestAnimationFrame(sync);  }  private addTouchListeners = () => {    const data = this._data;    const containersWrap = this.containersWrap;    const indicator = this.indicator;    const tabDomItems = this.tabBarItems;    const handleTransitionEnd = () => {      containersWrap.style.transition = this.transition();    };    containersWrap.addEventListener('webkitTransitionEnd', handleTransitionEnd);    containersWrap.addEventListener('transitionend', handleTransitionEnd);    containersWrap.addEventListener('touchstart', (e) => {      const touch = e.touches[0];      this.touchStartPoint = [touch.clientX, touch.clientY];      this.touchBeginTime = Date.now();      containersWrap.style.transform = getComputedStyle(containersWrap).transform;      containersWrap.style.transition = 'none';      try {        this.beginTransform = this.getTransformX(containersWrap.style.transform!);      } catch (e) {        console.warn('transform is invalid:' + containersWrap.style.transform);      }      indicator.style.transition = 'none';    });    containersWrap.addEventListener('touchmove', (e) => {      this.touchSliding = true;      const touch = e.touches[0];      this.touchCurrentPoint = [touch.clientX, touch.clientY];      this.distX = this.touchCurrentPoint[0] - this.touchStartPoint[0];      this.distY = this.touchCurrentPoint[1] - this.touchStartPoint[1];      const { distX, distY } = this;      this.distance = Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2));      const distance = this.distance;      // 处理左右滑动      if (distance > this.distanceThreshold && Math.abs(distX) > Math.abs(distY) && !this.lockSlide) {        if (this._currentIndex === 0 && !this.rebound && distX > 0) {          return;        }        if (this._currentIndex === this._data.length - 1 && !this.rebound && distX < 0) {          return;        }        const tabContainerWidth = this.tabContainerWidth;        const rate = Math.abs(distX / tabContainerWidth);        const currentTab = tabDomItems[this._currentIndex];        const currentTabWidth = currentTab.offsetWidth;        const currentTabLeft = currentTab.offsetLeft;        const targetTab = distX > 0 ? tabDomItems[this._currentIndex - 1] : tabDomItems[this._currentIndex + 1];        const diffWidth = targetTab.offsetWidth - currentTab.offsetWidth;        const distanceX = currentTab.offsetLeft - targetTab.offsetLeft;        const { indicatorOptions } = this;        if (this.indicatorOptions.width === 'cover') {          indicator.style.width = currentTabWidth + diffWidth * rate + 'px';          indicator.style.transform = `translateX(${currentTabLeft - distanceX * rate}px`;        } else if (indicatorOptions.width === 'content' || Utils.isPercent(indicatorOptions.width!)) {          const tabRate = indicatorOptions.width === 'content' ? 1 : Utils.parsePercent(indicatorOptions.width!);          const currentTabTextNode = tabDomItems[this._currentIndex].querySelector<HTMLElement>('[data-text-node]')!;          const currentTabTextRealWidth = currentTabTextNode.offsetWidth * tabRate;          const currentTabTextNodeOffsetLeft = Utils.getOffsetLeft(currentTabTextNode) + (currentTabTextNode.offsetWidth - currentTabTextRealWidth) / 2;          const targetTabTextNode = targetTab.querySelector<HTMLElement>('[data-text-node]')!;          const targetTabTextNodeRealWidth = targetTabTextNode.offsetWidth * tabRate;          const targetTabTextNodeOffsetLeft = Utils.getOffsetLeft(targetTabTextNode) + (targetTabTextNode.offsetWidth - currentTabTextRealWidth) / 2;          const textNodeDiffWidth = targetTabTextNodeRealWidth - currentTabTextRealWidth;          const textNodeDistanceX = currentTabTextNodeOffsetLeft - targetTabTextNodeOffsetLeft;          indicator.style.width = (currentTabTextRealWidth + textNodeDiffWidth * rate) + 'px';          indicator.style.transform = `translateX(${currentTabTextNodeOffsetLeft - textNodeDistanceX * rate}px`;        } else {          throw new Error('indicator width option is invalid (valid value:cover,content)');        }        containersWrap.style.transform = `translateX(${this.beginTransform + distX}px)`;      }    });    containersWrap.addEventListener('touchend', () => {      indicator.style.transition = this.indicatorTransition(this.touchEndTransitionTime);      const currentTabContainerWidth = this.tabContainerWidth;      const reset = () => {        // containersWrap.style.transition = this.transition;        containersWrap.style.transition = this.transition(this.touchEndTransitionTime);        containersWrap.style.transform = `translateX(${-this._currentIndex * currentTabContainerWidth}px)`;        // 指示器归位        this.syncIndicator(true, this.touchEndTransitionTime);      };      if (        (this._currentIndex === 0 && this.distX > 0) ||        (this._currentIndex === data.length - 1 && this.distX < 0)      ) {        // 归位        reset();        return;      }      const duration = Date.now() - this.touchBeginTime;      if (duration < 500 && !this.lockSlide) {        if (this.distX > this.slideThreshold) {          this.changeTab(this._currentIndex - 1, true, this.touchEndTransitionTime);          return;        }        if (-this.distX > this.slideThreshold) {          this.changeTab(this._currentIndex + 1, true, this.touchEndTransitionTime);          return;        }      } else {        if (this.distX > currentTabContainerWidth / 2) {          this.changeTab(this._currentIndex - 1, true, this.touchEndTransitionTime);          return;        }        if (-this.distX > currentTabContainerWidth / 2) {          this.changeTab(this._currentIndex + 1, true, this.touchEndTransitionTime);          return;        }      }      reset();      // this.setLockSlide(false);      this.lockSlide = false;    });  }  private initContainerListeners = (container: HTMLDivElement) => {    container.addEventListener('scroll', (e) => {      const target = e.target as HTMLDivElement;      // this.？setLockSlide(true);      this.lockSlide = true;      if (target.scrollTop + target.offsetHeight >= target.scrollHeight - this.scrollEndOffset) {        this.onScrollEnd(this.currentIndex);      }    });  }  private syncWidth = () => {    const containersWrap = this.containersWrap;    const tabContainerItems = Array.from(containersWrap.children) as HTMLDivElement[];    const tabDomItems = this.tabBarItems!;    const containerItemWidth = this.tabContainerWidth;    containersWrap.style.width = tabContainerItems.length * containerItemWidth + 'px';    tabContainerItems.forEach((container) => {      container.style.width = containerItemWidth + 'px';      containersWrap.style.width = tabContainerItems.length * containerItemWidth + 'px';    });    setTimeout(() => {      this.syncIndicator(false);    });    containersWrap.style.transition = 'none';    containersWrap.style.transform = `translateX(${-this.currentIndex * containerItemWidth}px)`;  }  private handleTabClick = (e: Event) => {    const clickedTab = e.currentTarget as HTMLDivElement;    const tabDomItems = this.tabBarItems;    const targetIndex = tabDomItems!.findIndex((o) => o === clickedTab);    this.changeTab(targetIndex);  }}