import { TabControllerOptions } from './types';import Utils from './utils';export default class TabController<T> {  get tabContainer() {    return this.tabsDom.querySelector('.__cus-tab-container') as HTMLDivElement;  }  get currentIndex() {    return this._currentIndex;  }  public get data() {    return this._data;  }  get transition() {    return `transform ${this.duration / 1000}s`;  }  get indicatorTransition() {    return `transform ${this.duration / 1000}s,width ${this.duration / 1000}s`;  }  get tabsDom() {    const res = document.querySelector(this.selector);    if (!res) {      throw new Error('tabs selector is invalid');    }    return res as HTMLDivElement;  }  get containersWrap(): HTMLDivElement {    return this.tabsDom.querySelector(`.__cus-tab-container-items-wrap`) as HTMLDivElement;  }  get tabBar(): HTMLElement {    const tabs = this.tabsDom;    const result = tabs.querySelector(`.${this.tabBarClass}`) as HTMLElement;    if (!result) {      throw new Error('tar bar id error');    }    return result;  }  get tabDomItems(): HTMLDivElement[] {    const tabBar = this.tabBar;    if (!tabBar) {      throw new Error('tab bar is undefined,tab bar id error');    }    // __cus-tabs-wrap    return Array.from(tabBar.querySelector(`.${this.tabsWrapClass}`)!.children) as HTMLDivElement[];  }  get tabContainers() {    return Array.from(this.containersWrap.children) as HTMLDivElement[];  }  get tabContainerWidth() {    return this.tabsDom.offsetWidth;  }  get tabBarTotalWidth(): number {    return this.tabDomItems.reduce((total, item) => {      return total + item.offsetWidth;    }, 0);  }  get indicator(): HTMLDivElement {    return this.tabsDom.querySelector('#__cus-indicator') as HTMLDivElement;  }  // 切换tab后的回调  public onChange: (index: number, data: T) => void;  // 当前tab文字颜色  private activeColor: string;  // 未激活tab文字颜色  private inactiveColor: string;  // 滑动起始点  private touchStartPoint: number[] = [];  // 当前滑动触摸点  private touchCurrentPoint: number[] = [];  // 滑动灵敏度（滑动距离超过这个值即发生滑动，越低越灵敏）  private distanceThreshold = 5;  // 快速滑动时触发切换tab的阈值  private slideThreshold = 40;  // 当前tab序号  private _currentIndex = 0;  // 已滑动横向距离  private distX = 0;  // 已滑动纵向距离  private distY = 0;  // 滑动起始点到当前点的距离  private distance = 0;  // 滑动开始时间  private touchBeginTime = 0;  // 滑动开始时容器的Transform值  private beginTransform = 0;  // 滑动动画持续时间  private duration: number;  // 数据  private _data: T[];  // 边缘是否回弹  private rebound: boolean;  // tab是否允许滚动  private tabCanScroll: boolean;  // tab bar的class属性  private tabBarClass: string = '__cus-tab-bar';  // tab container的class属性  private tabContainerClass: string = '__cus-tab-container';  // 是否锁定滑动  private lockSlide: boolean = false;  // 容器滚动到底部触发  private onScrollEnd: (i: number) => void;  // 触发onScrollEnd hook的偏移值  private scrollEndOffset: number;  // 组件根元素选择器  private selector: string;  // tab bar 外层包裹元素选择器  private tabsWrapClass = '__cus-tabs-wrap';  // 用来标识已初始化的tab的key  private tabInitKey = '__tabInit';  // 默认颜色  private defaultColor = '#409eff';  constructor(options?: TabControllerOptions<T>) {    const {      selector = '#__cus-tabs',      tabScroll = false, rebound = false, initIndex = 0, data = [], onChange = () => {      }, indicatorOptions = {        backgroundColor: this.defaultColor,        height: '2px',      }, activeColor = this.defaultColor, inactiveColor = '#000',      duration = 500,      onScrollEnd = () => {      },      scrollEndOffset = 0,    } = options || {};    this.selector = selector;    const tabs = document.querySelector(selector) as HTMLDivElement;    if (!tabs) {      throw new Error('tabs is not found');    }    const tabBar = tabs.querySelector(`.${this.tabBarClass}`)! as HTMLDivElement;    const tabContainer = tabs.querySelector(`.${this.tabContainerClass}`) as HTMLDivElement;    if (!tabBar) {      throw new Error('tab bar id error');    }    if (!tabContainer) {      throw new Error('tab container id error');    }    const { backgroundColor: indicatorColor = this.defaultColor, height: indicatorHeight } = indicatorOptions;    this.onScrollEnd = onScrollEnd;    this.scrollEndOffset = scrollEndOffset;    this.duration = duration;    this.inactiveColor = inactiveColor;    this.activeColor = activeColor;    this._currentIndex = 0;    this.rebound = rebound;    this.onChange = onChange;    this._data = data;    this.tabCanScroll = tabScroll;    const containersWrap = this.containersWrap;    const indicator = tabBar.querySelector<HTMLDivElement>('#__cus-indicator')!;    indicator.style.backgroundColor = indicatorColor;    indicator.style.transition = this.indicatorTransition;    indicator.style.height = indicatorHeight!;    tabBar.style.visibility = 'hidden';    tabContainer.style.visibility = 'hidden';    setTimeout(() => {      tabBar.style.visibility = 'visible';      tabContainer.style.visibility = 'visible';      const tabContainers = Array.from(containersWrap.children) as HTMLDivElement[];      containersWrap.style.width = tabContainers.length * this.tabContainerWidth + 'px';      window.addEventListener('resize', this.syncWidth);      const tabDomItems = this.tabDomItems!;      tabDomItems.forEach((o) => {        o.style.color = this.inactiveColor;        o.dataset[this.tabInitKey] = 'true';      });      // 初始化已激活tab      setTimeout(() => {        indicator.style.width = tabDomItems[0].offsetWidth + 'px';        tabDomItems[initIndex].style.color = this.activeColor;      });      containersWrap.style.transform = `translateX(0px)`;      if (!this.tabCanScroll) {        const tabsWrap = tabBar.querySelector<HTMLDivElement>('.__cus-tabs-wrap')!;        tabsWrap.style.display = 'flex';        tabsWrap.style.width = '100%';        tabsWrap.style.whiteSpace = 'normal';      }      tabDomItems.forEach((item) => {        if (!this.tabCanScroll) {          item.style.flex = '1';        }        item.addEventListener('click', this.handleTabClick);      });      const handleTransitionEnd = () => {        containersWrap.style.transition = this.transition;      };      containersWrap.addEventListener('webkitTransitionEnd', handleTransitionEnd);      containersWrap.addEventListener('transitionend', handleTransitionEnd);      containersWrap.addEventListener('touchstart', (e) => {        const touch = e.touches[0];        this.touchStartPoint = [touch.clientX, touch.clientY];        this.touchBeginTime = Date.now();        containersWrap.style.transform = getComputedStyle(containersWrap).transform;        containersWrap.style.transition = 'none';        this.beginTransform = this.getTransformX(containersWrap.style.transform!);        indicator.style.transition = 'none';      });      containersWrap.addEventListener('touchmove', (e) => {        const touch = e.touches[0];        this.touchCurrentPoint = [touch.clientX, touch.clientY];        this.distX = this.touchCurrentPoint[0] - this.touchStartPoint[0];        this.distY = this.touchCurrentPoint[1] - this.touchStartPoint[1];        const { distX, distY } = this;        this.distance = Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2));        const distance = this.distance;        if (this._currentIndex === 0 && !this.rebound && distX > 0) {          return;        }        if (this._currentIndex === this._data.length - 1 && !this.rebound && distX < 0) {          return;        }        if (distance > this.distanceThreshold && Math.abs(distX) > Math.abs(distY) && !this.lockSlide) {          const tabContainerWidth = this.tabContainerWidth;          const rate = Math.abs(distX / tabContainerWidth);          const currentTab = tabDomItems[this._currentIndex];          const currentTabWidth = currentTab.offsetWidth;          const currentTabLeft = currentTab.offsetLeft;          const targetTab = distX > 0 ? tabDomItems[this._currentIndex - 1] : tabDomItems[this._currentIndex + 1];          const diffWidth = targetTab.offsetWidth - currentTab.offsetWidth;          const distanceX = currentTab.offsetLeft - targetTab.offsetLeft;          indicator.style.width = currentTabWidth + diffWidth * rate + 'px';          indicator.style.transform = `translateX(${currentTabLeft - distanceX * rate}px`;          containersWrap.style.transform = `translateX(${this.beginTransform + distX}px)`;        }      });      containersWrap.addEventListener('touchend', () => {        indicator.style.transition = this.indicatorTransition;        const currentTabContainerWidth = this.tabContainerWidth;        const reset = () => {          containersWrap.style.transition = this.transition;          containersWrap.style.transform = `translateX(${-this._currentIndex * currentTabContainerWidth}px)`;          // 指示器归位          const currentTab = tabDomItems[this._currentIndex];          indicator.style.transition = this.indicatorTransition;          indicator.style.transform = `translateX(${currentTab.offsetLeft}px)`;          indicator.style.width = `${currentTab.offsetWidth}px`;        };        if (          (this._currentIndex === 0 && this.distX > 0) ||          (this._currentIndex === data.length - 1 && this.distX < 0)        ) {          // 归位          reset();          return;        }        const duration = Date.now() - this.touchBeginTime;        if (duration < 500 && !this.lockSlide) {          if (this.distX > this.slideThreshold) {            this.changeTab(this._currentIndex - 1);            return;          }          if (-this.distX > this.slideThreshold) {            this.changeTab(this._currentIndex + 1);            return;          }        } else {          if (this.distX > currentTabContainerWidth / 2) {            this.changeTab(this._currentIndex - 1);            return;          }          if (-this.distX > currentTabContainerWidth / 2) {            this.changeTab(this._currentIndex + 1);            return;          }        }        reset();        this.lockSlide = false;      });      tabContainers.forEach((container) => {        this.addContainerScrollListener(container);      });      this.changeTab(initIndex);    });  }  public push = (tabItem: T) => {    const containersWrap = this.containersWrap;    containersWrap.style.width = `${containersWrap.offsetWidth + this.tabContainerWidth}px`;    this._data.push(tabItem);    setTimeout(() => {      this.syncWidth();      const tabDomItems = this.tabDomItems;      const uninitializedTabs = tabDomItems.filter((o) => {        return !o.dataset[this.tabInitKey];      });      uninitializedTabs.forEach((newTab) => {        const containers = this.tabContainers;        newTab.addEventListener('click', this.handleTabClick);        this.addContainerScrollListener(containers[containers.length - 1]);      });    });  }  public remove = (i: number) => {    this._data.splice(i, 1);    const currentIndex = this.currentIndex;    if (i === currentIndex) {      this.changeTab(currentIndex === 0 ? 0 : currentIndex - 1);    }    setTimeout(() => {      this.syncWidth();    });  }  public changeTab: (targetIndex: number, isAnimate?: boolean) => void = (targetIndex, isAnimate = true) => {    const { indicator, containersWrap: containersWrap, _data } = this;    if (targetIndex >= _data.length) {      console.warn('target index out of range');      return;    }    this.onChange(targetIndex, _data[targetIndex]);    if (targetIndex === this._currentIndex) {      return;    }    const tabContainer = this.tabContainer;    const tabContainerItemWidth = tabContainer.offsetWidth;    const tabBarItems = this.tabDomItems!;    const targetTab = tabBarItems[targetIndex];    tabBarItems.forEach((o) => {      o.style.color = this.inactiveColor;      o.classList.remove('active');    });    this._currentIndex = targetIndex;    targetTab.classList.add('active');    targetTab.style.color = this.activeColor;    // 移动到相应tab    indicator.style.transform = `translateX(${targetTab.offsetLeft}px)`;    indicator.style.width = `${targetTab.offsetWidth}px`;    containersWrap.style.transition = isAnimate ? this.transition : 'none';    setTimeout(() => {      containersWrap.style.transform = `translateX(${-tabContainerItemWidth * targetIndex}px)`;      setTimeout(() => {        containersWrap.style.transition = this.transition;      });    });    // 处理tab bar 滚动    if (this.tabCanScroll) {      const tabBar = this.tabBar;      const tabBarSpace = 50;      const targetTabOffsetLeft = targetTab.offsetLeft;      const targetTabWidth = targetTab.offsetWidth;      const tabBarScrollLeft = tabBar.scrollLeft;      const containerWidth = this.tabContainerWidth;      const rightBoundary = targetTabOffsetLeft + targetTabWidth + tabBarSpace;      const leftBoundary = targetTabOffsetLeft - tabBarSpace;      const tabBarTotalWidth = this.tabBarTotalWidth;      const tabContainerWidth = this.tabContainerWidth;      if (rightBoundary > tabBarScrollLeft + containerWidth) {        if (rightBoundary >= tabBarTotalWidth) {          Utils.animateScrollTo(tabBar, { x: tabBarTotalWidth - containerWidth, y: 0 }, this.duration);        } else {          Utils.animateScrollTo(tabBar, { x: rightBoundary - containerWidth, y: 0 }, this.duration);        }      }      if (leftBoundary < tabBarScrollLeft) {        Utils.animateScrollTo(tabBar, { x: leftBoundary < 0 ? 0 : leftBoundary, y: 0 }, this.duration);      }    }  }  public getTransformX(transform: string): number {    if (!transform || transform === 'none') {      return 0;    }    if (transform.startsWith('translateX')) {      return parseInt(transform.match(/translateX\(([\-0-9\.]+)px\)/)![1], 10);    }    if (transform.startsWith('matrix')) {      return parseInt(transform.match(/matrix\(.*? ([\-0-9\.]+), [0-9\.]+\)/)![1], 10);    }    console.warn('unknown transform');    return 0;  }  private addContainerScrollListener = (container: HTMLDivElement) => {    container.addEventListener('scroll', (e) => {      const target = e.target as HTMLDivElement;      this.lockSlide = true;      if (target.scrollTop + target.offsetHeight >= target.scrollHeight - this.scrollEndOffset) {        this.onScrollEnd(this.currentIndex);      }    });  }  private syncWidth = () => {    const containersWrap = this.containersWrap;    const tabContainerItems = Array.from(containersWrap.children) as HTMLDivElement[];    const tabDomItems = this.tabDomItems!;    const containerItemWidth = this.tabContainerWidth;    containersWrap.style.width = tabContainerItems.length * containerItemWidth + 'px';    tabContainerItems.forEach((container) => {      container.style.width = containerItemWidth + 'px';      containersWrap.style.width = tabContainerItems.length * containerItemWidth + 'px';    });    setTimeout(() => {      this.indicator.style.width = tabDomItems[0].offsetWidth + 'px';    });    containersWrap.style.transition = 'none';    containersWrap.style.transform = `translateX(${-this.currentIndex * containerItemWidth}px)`;  }  private handleTabClick = (e: Event) => {    const clickedTab = e.currentTarget as HTMLDivElement;    const tabDomItems = this.tabDomItems;    const targetIndex = tabDomItems!.findIndex((o) => o === clickedTab);    this.changeTab(targetIndex);  }}