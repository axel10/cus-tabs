import TabStore from './tabStore';import { TabControllerOptions, TabItem } from './types';export default class TabController {  get currentIndex() {    return this._currentIndex;  }  get data() {    return this._data;  }  private activeColor = '#00BFFF';  private inactiveColor = '#000';  private touchStartPoint: number[] = [];  private touchCurrentPoint: number[] = [];  private distanceThreshold = 5;  private slideThreshold = 40;  private sliding = false;  private _currentIndex = 0;  private distX = 0;  private distY = 0;  private distance = 0;  private touchBeginTime = 0;  private beginTransform = 0;  private onChange: (index: number, data: any) => void;  private indicator: HTMLDivElement;  private tabBar: HTMLDivElement;  private transition = `transform .5s`;  private containerItemsWrap: HTMLDivElement;  private tabContainer: HTMLDivElement;  private _data: TabItem[];  private store: TabStore;  private rebound: boolean;  private tabScroll: boolean;  changeTab: (targetIndex: number) => void = targetIndex => {    const { tabContainer, indicator, containerItemsWrap, _data } = this;    if (targetIndex === this._currentIndex) {      return;    }    if (targetIndex >= _data.length) {      console.warn('target index out of range');      return;    }    const tabContainerItemWidth = tabContainer.offsetWidth;    const tabBarItems = Array.from(this.tabBar.children) as HTMLDivElement[];    const clickedTab = tabBarItems[targetIndex];    tabBarItems.forEach(o => {      o.style.color = this.inactiveColor;    });    this._currentIndex = targetIndex;    clickedTab.style.color = this.activeColor;    // 移动到相应tab    indicator.style.transform = `translateX(${clickedTab.offsetLeft}px)`;    indicator.style.width = `${getComputedStyle(clickedTab).width}px`;    containerItemsWrap.style.transition = this.transition;    setTimeout(() => {      containerItemsWrap.style.transform = `translateX(${-tabContainerItemWidth * targetIndex}px)`;    });    this.onChange(this._currentIndex, _data[this._currentIndex]);  };  getTransformX(transform: string): number {    if (!transform || transform === 'none') {      return 0;    }    if (transform.startsWith('translateX')) {      return parseInt(transform.match(/translateX\(([\-0-9\.]+)px\)/)![1]);    }    if (transform.startsWith('matrix')) {      return parseInt(transform.match(/matrix\(.*? ([\-0-9\.]+), [0-9\.]+\)/)![1]);    }    console.warn('unknown transform');    return 0;  }  constructor(options?: TabControllerOptions) {    const {      tabScroll = false, rebound = false, initIndex = 0, tabBarId = '__cus-tab-bar', tabContainerId = '__cus-tab-container', data = [], onChange = () => {      }    } = options ? options : {};    const tabBar = document.getElementById(tabBarId)! as HTMLDivElement;    const tabContainer = document.getElementById(tabContainerId) as HTMLDivElement;    if (!tabBar) {      throw new Error('tab bar id error');    }    if (!tabContainer) {      throw new Error('tab container id error');    }    this.tabBar = tabBar;    this._currentIndex = initIndex;    this.rebound = rebound;    this.tabContainer = tabContainer;    this.onChange = onChange;    this._data = data;    this.tabScroll = tabScroll;    const containerItemsWrap = tabContainer.querySelector<HTMLDivElement>('.tab-container-items-wrap')!;    this.containerItemsWrap = containerItemsWrap;    const indicator = tabBar.querySelector<HTMLDivElement>('#__cus-indicator')!;    this.indicator = indicator    this.store = new TabStore({ /*tabBar, tabContainer: containerWrap*/ });    setTimeout(()=>{      const tabContainerItems = Array.from(containerItemsWrap.children) as HTMLDivElement[];      const tabContainerItemWidth = tabContainer.offsetWidth;      const tabBarDomItems = Array.from(tabBar.children) as HTMLDivElement[];      setTimeout(() => {        indicator.style.width = tabBarDomItems[0].offsetWidth + 'px';      });      containerItemsWrap.style.transform = `translateX(${initIndex * tabContainerItemWidth}px)`;      this.store.commit('setData', data);      if (!this.tabScroll) {        tabBar.style.display = 'flex';      }      tabBarDomItems.forEach(item => {        if (!this.tabScroll) {          item.style.flex = '1';        }        item.addEventListener('click', (e) => {          const clickedTab = e.currentTarget as HTMLDivElement;          const targetIndex = tabBarDomItems.findIndex(o => o === clickedTab);          this.changeTab(targetIndex);        });      });      tabContainerItems.forEach(container => {        container.style.width = tabContainerItemWidth + 'px';      });      containerItemsWrap.addEventListener('touchstart', (e) => {        const touch = e.touches[0];        this.touchStartPoint = [touch.clientX, touch.clientY];        this.touchBeginTime = Date.now();        containerItemsWrap.style.transition = 'none';        containerItemsWrap.style.transform = getComputedStyle(containerItemsWrap).transform;        this.beginTransform = this.getTransformX(containerItemsWrap.style.transform!);      });      containerItemsWrap.addEventListener('touchmove', (e) => {        const touch = e.touches[0];        this.touchCurrentPoint = [touch.clientX, touch.clientY];        this.distX = this.touchCurrentPoint[0] - this.touchStartPoint[0];        this.distY = this.touchCurrentPoint[1] - this.touchStartPoint[1];        const { distX, distY } = this;        this.distance = Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2));        const distance = this.distance;        if (this._currentIndex === 0 && !this.rebound && distX > 0) {          return;        }        if (this._currentIndex === this._data.length - 1 && !this.rebound && distX < 0) {          return;        }        if (distance > this.distanceThreshold && Math.abs(distX) > Math.abs(distY)) {          this.sliding = true;          // const currentTransform = this.getTransformX(containerItemsWrap.style.transform!);          containerItemsWrap.style.transform = `translateX(${this.beginTransform + distX}px)`;        }      });      containerItemsWrap.addEventListener('touchend', () => {        const reset = () => {          containerItemsWrap.style.transition = `transform .5s`;          containerItemsWrap.style.transform = `translateX(${-this._currentIndex * tabContainerItemWidth}px)`;        };        if (          (this._currentIndex === 0 && this.distX > 0) ||          (this._currentIndex === data.length - 1 && this.distX < 0)        ) {          // 归位          reset();          return;        }        const duration = Date.now() - this.touchBeginTime;        if (duration < 500) {          if (this.distX > this.slideThreshold) {            this.changeTab(this._currentIndex - 1);            return;          }          if (-this.distX > this.slideThreshold) {            this.changeTab(this._currentIndex + 1);            return;          }        } else {          if (this.distX > tabContainerItemWidth / 2) {            this.changeTab(this._currentIndex - 1);            return;          }          if (-this.distX > tabContainerItemWidth / 2) {            this.changeTab(this._currentIndex + 1);            return;          }        }        reset();      });      containerItemsWrap.style.width = tabContainerItems.length * tabContainerItemWidth + 'px';    })  }}