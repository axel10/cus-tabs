import TabStore from './TabStore';import { TabControllerOptions, TabItem } from './types';import Utils from '@/utils';export default class TabController {  get currentIndex() {    return this._currentIndex;  }  get data() {    return this._data;  }  get transition() {    return `transform ${this.duration / 1000}s`;  }  private indicatorColor: string;  private activeColor: string;  private inactiveColor: string;  private touchStartPoint: number[] = [];  private touchCurrentPoint: number[] = [];  private distanceThreshold = 5;  private slideThreshold = 40;  private sliding = false;  private _currentIndex = 0;  private distX = 0;  private distY = 0;  private distance = 0;  private touchBeginTime = 0;  private beginTransform = 0;  private onChange: (index: number, data: any) => void;  private indicator: HTMLDivElement;  private duration = 500;  private containerItemsWrap: HTMLDivElement;  private tabContainer: HTMLDivElement;  private _data: TabItem[];  private store: TabStore;  private rebound: boolean;  private tabCanScroll: boolean;  private tabBarId: string;  private tabBarItemClass = '__cus-tab-bar-item';  get tabDomItems(): HTMLDivElement[] {    const tabBar = document.getElementById(this.tabBarId);    if (!tabBar) {      throw new Error('tab bar is undefined,tab bar id error');    }    return Array.from(tabBar.querySelectorAll(`.${this.tabBarItemClass}`)) as HTMLDivElement[];  }  get tabBar(): HTMLElement {    const result = document.getElementById(this.tabBarId);    if (!result) {      throw new Error('tar bar id error');    }    return result;  }  get tabContainerWidth() {    if (!this.tabContainer) {      throw new Error('tab container not found');    }    return this.tabContainer.offsetWidth;  }  get tabBarTotalWidth(): number {    return this.tabDomItems.reduce((total, item) => {      return total + item.offsetWidth;    }, 0);  }  syncWidth() {    const tabContainerItems = Array.from(this.containerItemsWrap.children) as HTMLDivElement[];    const tabDomItems = this.tabDomItems!;    const containerItemWidth = this.tabContainerWidth;    this.containerItemsWrap.style.width = tabContainerItems.length * containerItemWidth + 'px';    tabContainerItems.forEach((container) => {      container.style.width = containerItemWidth + 'px';      this.containerItemsWrap.style.width = tabContainerItems.length * containerItemWidth + 'px';    });    setTimeout(() => {      this.indicator.style.width = tabDomItems[0].offsetWidth + 'px';    });    this.containerItemsWrap.style.transition = 'none';    this.containerItemsWrap.style.transform = `translateX(${-this.currentIndex * containerItemWidth}px)`;  }  push(tabItem: TabItem) {    this._data.push(tabItem);    setTimeout(() => {      this.syncWidth();      const tabDomItems = this.tabDomItems;      const newTab = tabDomItems[tabDomItems.length - 1];      newTab.addEventListener('click', this.handleTabClick);    });  }  handleTabClick = (e: Event) => {    const clickedTab = e.currentTarget as HTMLDivElement;    const tabDomItems = this.tabDomItems;    const targetIndex = tabDomItems!.findIndex((o) => o === clickedTab);    this.changeTab(targetIndex);  };  constructor(options?: TabControllerOptions) {    const {      tabScroll = false, rebound = false, initIndex = 0, tabBarId = '__cus-tab-bar',      tabContainerId = '__cus-tab-container', data = [], onChange = () => {      }, indicatorColor = '#409eff', activeColor = '#409eff', inactiveColor = '#000'    } = options ? options : {};    const tabBar = document.getElementById(tabBarId)! as HTMLDivElement;    const tabContainer = document.getElementById(tabContainerId) as HTMLDivElement;    if (!tabBar) {      throw new Error('tab bar id error');    }    if (!tabContainer) {      throw new Error('tab container id error');    }    this.indicatorColor = indicatorColor;    this.inactiveColor = inactiveColor;    this.activeColor = activeColor;    this.tabBarId = tabBarId;    this._currentIndex = 0;    this.rebound = rebound;    this.tabContainer = tabContainer;    this.onChange = onChange;    this._data = data;    this.tabCanScroll = tabScroll;    const containerItemsWrap = tabContainer.querySelector<HTMLDivElement>('.__cus-tab-container-items-wrap')!;    this.containerItemsWrap = containerItemsWrap;    const indicator = tabBar.querySelector<HTMLDivElement>('#__cus-indicator')!;    this.indicator = indicator;    indicator.style.backgroundColor = this.indicatorColor;    this.store = new TabStore({});    setTimeout(() => {      /*            this.tabBar.addEventListener('scroll', (e) => {              console.log(this.tabBar.scrollLeft);            });      */      const tabContainerItems = Array.from(containerItemsWrap.children) as HTMLDivElement[];      const tabContainerItemWidth = this.tabContainerWidth;      containerItemsWrap.style.width = tabContainerItems.length * tabContainerItemWidth + 'px';      window.addEventListener('resize', this.syncWidth);      const tabDomItems = this.tabDomItems!;      setTimeout(() => {        indicator.style.width = tabDomItems[0].offsetWidth + 'px';      });      // containerItemsWrap.style.transform = `translateX(${initIndex * tabContainerItemWidth}px)`;      containerItemsWrap.style.transform = `0px`;      this.store.commit('setData', data);      if (!this.tabCanScroll) {        const tabsWrap = tabBar.querySelector<HTMLDivElement>('.__cus-tabs-wrap')!;        tabsWrap.style.display = 'flex';        tabsWrap.style.width = '100%';      }      tabDomItems.forEach((item) => {        if (!this.tabCanScroll) {          item.style.flex = '1';        }        item.addEventListener('click', this.handleTabClick);      });      tabContainerItems.forEach((container) => {        container.style.width = tabContainerItemWidth + 'px';      });      const handleTransitionEnd = () => {        this.sliding = false;        containerItemsWrap.style.transition = this.transition;      };      containerItemsWrap.addEventListener('webkitTransitionEnd', handleTransitionEnd);      containerItemsWrap.addEventListener('transitionend', handleTransitionEnd);      containerItemsWrap.addEventListener('touchstart', (e) => {        this.sliding = true;        const touch = e.touches[0];        this.touchStartPoint = [touch.clientX, touch.clientY];        this.touchBeginTime = Date.now();        containerItemsWrap.style.transform = getComputedStyle(containerItemsWrap).transform;        containerItemsWrap.style.transition = 'none';        this.beginTransform = this.getTransformX(containerItemsWrap.style.transform!);      });      containerItemsWrap.addEventListener('touchmove', (e) => {        const touch = e.touches[0];        this.touchCurrentPoint = [touch.clientX, touch.clientY];        this.distX = this.touchCurrentPoint[0] - this.touchStartPoint[0];        this.distY = this.touchCurrentPoint[1] - this.touchStartPoint[1];        const { distX, distY } = this;        this.distance = Math.sqrt(Math.pow(distX, 2) + Math.pow(distY, 2));        const distance = this.distance;        if (this._currentIndex === 0 && !this.rebound && distX > 0) {          return;        }        if (this._currentIndex === this._data.length - 1 && !this.rebound && distX < 0) {          return;        }        if (distance > this.distanceThreshold && Math.abs(distX) > Math.abs(distY)) {          containerItemsWrap.style.transform = `translateX(${this.beginTransform + distX}px)`;        }      });      containerItemsWrap.addEventListener('touchend', () => {        const currentTabContainerWidth = this.tabContainerWidth;        const reset = () => {          containerItemsWrap.style.transition = this.transition;          containerItemsWrap.style.transform = `translateX(${-this._currentIndex * currentTabContainerWidth}px)`;        };        if (          (this._currentIndex === 0 && this.distX > 0) ||          (this._currentIndex === data.length - 1 && this.distX < 0)        ) {          // 归位          reset();          return;        }        const duration = Date.now() - this.touchBeginTime;        if (duration < 500) {          if (this.distX > this.slideThreshold) {            this.changeTab(this._currentIndex - 1);            return;          }          if (-this.distX > this.slideThreshold) {            this.changeTab(this._currentIndex + 1);            return;          }        } else {          if (this.distX > currentTabContainerWidth / 2) {            this.changeTab(this._currentIndex - 1);            return;          }          if (-this.distX > currentTabContainerWidth / 2) {            this.changeTab(this._currentIndex + 1);            return;          }        }        reset();      });      this.changeTab(initIndex);    });  }  public changeTab: (targetIndex: number, isAnimate?: boolean) => void = (targetIndex, isAnimate = true) => {    const { tabContainer, indicator, containerItemsWrap, _data } = this;    if (targetIndex === this._currentIndex) {      return;    }    if (targetIndex >= _data.length) {      console.warn('target index out of range');      return;    }    const tabContainerItemWidth = tabContainer.offsetWidth;    const tabBarItems = this.tabDomItems!;    const targetTab = tabBarItems[targetIndex];    tabBarItems.forEach((o) => {      o.style.color = this.inactiveColor;    });    this._currentIndex = targetIndex;    targetTab.style.color = this.activeColor;    // 移动到相应tab    indicator.style.transform = `translateX(${targetTab.offsetLeft}px)`;    indicator.style.width = `${targetTab.offsetWidth}px`;    containerItemsWrap.style.transition = isAnimate ? this.transition : 'none';    setTimeout(() => {      containerItemsWrap.style.transform = `translateX(${-tabContainerItemWidth * targetIndex}px)`;      setTimeout(() => {        containerItemsWrap.style.transition = this.transition;      });    });    // 处理tab bar 滚动    if (this.tabCanScroll) {      const tabBar = this.tabBar;      const tabBarSpace = 50;      const targetTabOffsetLeft = targetTab.offsetLeft;      const targetTabWidth = targetTab.offsetWidth;      const tabBarScrollLeft = tabBar.scrollLeft;      const containerWidth = this.tabContainerWidth;      const rightBoundary = targetTabOffsetLeft + targetTabWidth + tabBarSpace;      const leftBoundary = targetTabOffsetLeft - tabBarSpace;      const tabBarTotalWidth = this.tabBarTotalWidth;      if (rightBoundary > tabBarScrollLeft + containerWidth) {        if (rightBoundary >= tabBarTotalWidth) {          // tabBarWrap.style.transform = `translateX(${-(tabBarWrapWidth - containerWidth)}px)`;          Utils.animateScrollTo(tabBar, { x: tabBarTotalWidth - containerWidth, y: 0 }, this.duration);        } else {          Utils.animateScrollTo(tabBar, { x: rightBoundary - containerWidth, y: 0 }, this.duration);        }        // tabBarWrap.style.transform = `translateX(${-(rightBoundary - containerWidth)}px)`;      }      if (leftBoundary < tabBarScrollLeft) {        // tabBarWrap.style.transform = `translateX(${leftBoundary < 0 ? 0 : -leftBoundary}px)`;        Utils.animateScrollTo(tabBar, { x: leftBoundary < 0 ? 0 : leftBoundary, y: 0 }, this.duration);      }    }    this.onChange(this._currentIndex, _data[this._currentIndex]);  };  public getTransformX(transform: string): number {    if (!transform || transform === 'none') {      return 0;    }    if (transform.startsWith('translateX')) {      return parseInt(transform.match(/translateX\(([\-0-9\.]+)px\)/)![1], 10);    }    if (transform.startsWith('matrix')) {      return parseInt(transform.match(/matrix\(.*? ([\-0-9\.]+), [0-9\.]+\)/)![1], 10);    }    console.warn('unknown transform');    return 0;  }}